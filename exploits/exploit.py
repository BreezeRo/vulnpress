import urllib.request
import urllib.error
import urllib.parse
import http.client
import http.cookiejar
import os
import sys
import inspect
from bs4 import BeautifulSoup
from exploits.validators import *
from db.db import Db
from db.db import Exploit as DBExploit


class Exploit(object):
    exploits = {'found': {}, 'not_found': {}}

    def __init__(self, hostname, loggedin=False):
        self.hostname = hostname
        self.loggedin = loggedin
        self.db = Db()

    def exploit(self):
        for exploit_type in self.db.get_exploit_types():
            for exploit in self.db.get_exploits_by_exploit_type(exploit_type.id):
                self.run_exploit(exploit)

    def exploit_type(self, type_id):
        for exploit in self.db.get_exploits_by_exploit_type(type_id):
            self.run_exploit(exploit)

    def run_exploit(self, exploit: DBExploit):
        if exploit.is_authenticated and not self.loggedin:
            pass
        else:
            self.validate_response(
                exploit, self.do_request(exploit, exploit.exploit_body if exploit.exploit_body is not None else '')
            )

    def validate_response(self, exploit: DBExploit, response):
        if self.get_validator_by_id(exploit.validator_id).validate(response):
            self.exploit_found(self.get_exploit_info(exploit))
        else:
            self.exploit_not_found(self.get_exploit_info(exploit))

    def do_request(self, exploit: DBExploit, data):
        return self.request(hostname=self.hostname + exploit.exploit_url, data=data,
                            headers=eval(exploit.exploit_headers) if exploit.exploit_headers is not None else {},
                            method=exploit.request_method,
                            urlencode=exploit.is_url_encode)

    def exploit_found(self, exploit_info):
        self.exploits['found'][exploit_info['exploit_id']] = {
            'name': exploit_info['exploit_name'],
            'version': exploit_info['exploit_version'],
            'exploiturl': exploit_info['exploit_url']}

    def exploit_not_found(self, exploit_info):
        self.exploits['not_found'][exploit_info['exploit_id']] = {
            'name': exploit_info['exploit_name'],
            'version': exploit_info['exploit_version'],
            'exploiturl': exploit_info['exploit_url']}

    @staticmethod
    def request(hostname, data, urlencode=False, headers={}, method='GET', encode='utf-8', decode='iso-8859-1'):
        try:
            if urlencode:
                data = urllib.parse.urlencode(eval(data))
            request = urllib.request.Request(hostname, data=data.encode(encode, 'ignore'), headers=headers,
                                             method=method)
            response = urllib.request.urlopen(request, timeout=20)
            data = response.read().decode(decode, 'ignore')
            response.close()

            return data

        except Exception:
            pass

    @staticmethod
    def login(hostname, username, password):
        # Attempt Login
        cj = http.cookiejar.CookieJar()
        opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))
        url = hostname + '/wp-login.php'
        data = {'log': username, 'pwd': password, 'submit': 'Log In'}
        data = urllib.parse.urlencode(data)
        opener.open(url, data.encode('utf-8'))

        # Verify successful login
        response = opener.open(hostname)
        soup = BeautifulSoup(response)
        atags = soup.find_all('a')
        if atags:
            for atag in atags:
                hrefs = atag.get('href')
                if hostname + '/wp-login.php?action=logout' in hrefs:
                    return True

    @staticmethod
    def check_file(file):
        if not os.path.isfile(file) and not os.access(file, os.R_OK):
            print('[X] ' + file + ' file is missing or not readable')
            sys.exit(1)
        else:
            return file

    @staticmethod
    def get_validator_by_id(validator_id):
        attribute = '__validator_id__'
        for name, obj in inspect.getmembers(sys.modules[__name__]):
            if hasattr(obj, attribute) and getattr(obj, attribute) == validator_id:
                return obj()
        raise ValueError('Could not find Validator with validator id %d' % validator_id)

    @staticmethod
    def get_exploit_info(exploit: DBExploit):
        return {
            'exploit_id': exploit.id,
            'exploit_name': exploit.name,
            'exploit_version': exploit.version,
            'exploit_url': exploit.url
        }
